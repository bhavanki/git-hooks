#!/usr/bin/env bash
#
# Copyright (c) 2020, Bill Havanki <bill@havanki.com>
# Copyright (c) 2010-2014, Benjamin C. Meyer <ben@meyerhome.net>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the project nor the
#    names of its contributors may be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ''AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

# Checks if git-hooks is installed.
# Returns: 0 if git-hooks --install has probably been run on this repository,
#   non-zero otherwise or if not in a repository
function is_hooks_installed
{
    GITDIR="$(git rev-parse --git-dir)"
     # shellcheck disable=SC2181
    if [ ! $? -eq 0 ] ; then
        return 1
    fi
    [ -f "${GITDIR}/hooks/pre-commit" ] && grep -q 'git-hooks' "${GITDIR}/hooks/pre-commit" 2> /dev/null
}

# All of the possible hook directories
hook_dir_names=(applypatch-msg commit-msg post-applypatch post-checkout post-commit post-merge post-receive pre-applypatch pre-auto-gc pre-commit prepare-commit-msg pre-rebase pre-receive update pre-push)

# Echoes all of the supported hook directories, one per line. Each directory
# name is prefixed with its "title". The directories do not necessarily exist.
# Argument: specific hook to list directories for (optional)
function hook_dirs
{
    if [ -n "${1}" ] ; then
        hook="/${1}"
    else
        hook=""
    fi
    # The user hook directory
    echo "User:${HOME}/.git_hooks${hook}"
    if git rev-parse --git-dir &> /dev/null; then
        if [ "$(git rev-parse --is-bare-repository)" = 'false' ]; then
            cd "$(git rev-parse --show-toplevel)"
            # The repository directories
            echo "Repository-1:${PWD}/git_hooks${hook}"
            echo "Repository-2:${PWD}/.githooks${hook}"
        fi
    fi
    # The global hook directory
    if git config --get hooks.global > /dev/null; then
        echo "Global:$(git config hooks.global)${hook}"
    fi
}

# Lists (echoes) all of the hooks in a hook directory
# Arguments: hook directory, number of levels for search
function list_hooks_in_dir
{
    path="${1}"
    level="${2}"

    find --help 2>&1 | grep -- '-L' 2>/dev/null >/dev/null
    if [ $? -eq 1 ] ; then
       Lopt=
    else
       Lopt=-L
    fi

    find ${Lopt} "${path}/" \
        -mindepth "${level}" \
        -maxdepth "${level}" \
        \( -perm -100 -o -perm -010 -o -perm -001 \) \
        -type f 2>/dev/null \
        | grep -v "^.$" | sort
}

# Lists all hooks.
function list_hooks
{
    local directories=()
    while IFS='' read -r line; do directories+=("$line"); done < <(hook_dirs)

    local hook_name=
    local last_dir=
    local current_dir=

    local space_size=35
    local about=

    echo 'Listing user, repository, and global hooks:'
    echo ""

    for dirlisting in "${directories[@]}"; do
        local name="${dirlisting%%:*}"
        local dir="${dirlisting#*:}"
        local exists
        if [[ ! -d "$dir" ]]; then
            exists=" (not present)"
        else
            exists=
        fi
        echo -e "\033[0;33m${name}\033[0m - ${dir}${exists}"
        for hook in $(list_hooks_in_dir "${dir}" 2) ; do
            hook_name=$(basename "$hook")
            current_dir=$(dirname "$hook")
            if [ "$current_dir" != "$last_dir" ]; then
                echo "  $(basename "$current_dir")"
                last_dir="$current_dir"
            fi
            about=$(${hook} "--about")
            echo "    ""$(printf "%-${space_size}s%s" "$(echo -e "\033[1;36m${hook_name}\033[0m___" | sed -e 's/-/_/g' )"  | sed -e 's/ /-/g' -e 's/_/ /g' )""- $about"
        done
        echo
    done
}

# Runs all of the hook scripts in a directory.
# Arguments: hook directory, arguments for each hook script
# Side effect: exports last_run_hook with the command line used to run the
#   last hook script (in case of error)
function run_hooks
{
    dir="${1}"
    if [[ -z ${dir} || ! -d "${dir}" ]] ; then
        # This shouldn't happen anyway
        echo "run_hooks requires a directory name as an argument."
        return 1
    fi
    shift 1
    for hook in $(list_hooks_in_dir "${dir}" 1); do
        export last_run_hook="${hook} $*"
        if [ -n "${GIT_HOOKS_VERBOSE}" ] ; then
            echo -n "@@ Running hook: "
            echo -n "$(basename "$(dirname "${hook}")")"
            echo "/$(basename "${hook}")"
        fi
        "${hook}" "$@"
    done
}

# Runs all of the scripts for a hook. This function exits immediately if any
# script fails.
# Arguments: hook, arguments for each hook script
function run_hook
{
    set -e
    if [ -z "$1" ]; then
        echo "run requires a hook argument"
        return 1
    fi
    hook=$(basename "${1}")
    shift 1
    local directories=()
    while IFS='' read -r line; do directories+=("$line"); done < <(hook_dirs "${hook}")
    for dirlisting in "${directories[@]}"; do
        local dir="${dirlisting#*:}"
        if [ ! -d "${dir}" ] ; then
            continue
        fi
        run_hooks "${dir}" "$@"
    done
    set +e
}

# Writes delegating scripts for each kind of hook. Existing hook scripts are
# saved off.
# Arguments: directory to write to, script contents (same for every hook)
function install_hooks_into
{
    DIR=$1
    cd "${DIR}"

    if [ -d hooks ]; then
        mv hooks hooks.old
    else
        # Creating an empty directory will allow uninstall to work
        mkdir hooks.old
    fi
    mkdir hooks
    cd hooks
    for file in "${hook_dir_names[@]}"
    do
        echo "${2}" > "${file}"
        chmod +x "${file}"
    done
}

# Writes delegating scripts into the current git repository.
function install_hooks
{
    GITDIR=$(git rev-parse --git-dir)
     # shellcheck disable=SC2181
    if [ ! $? -eq 0 ] ; then
        echo "install must be run inside a git repository"
        return 1
    fi
    cd "${GITDIR}"
    if [ -d hooks.old ] ; then
        echo "hooks.old already exists, perhaps you already installed?"
        return 1
    fi
    # shellcheck disable=SC2016
    cmd='#!/usr/bin/env bash
git-hooks run "$0" "$@"';
    install_hooks_into "${PWD}" "${cmd}"

    echo "git-hooks is now installed in this repository"
}

# Destroys delegating scripts in the current git repository, and replaces the
# original hooks saved during installation.
function uninstall_hooks
{
    GITDIR=$(git rev-parse --git-dir)
     # shellcheck disable=SC2181
    if [ ! $? -eq 0 ] ; then
        echo "uninstall must be run inside a git repository"
        return 1
    fi
    cd "${GITDIR}"
    if [ ! -d hooks.old ] ; then
        echo "Error, hooks.old doesn't exists, aborting uninstall to not destroy something"
        return 1
    fi
    rm -rf hooks
    mv hooks.old hooks

    echo "git-hooks has been uninstalled from this repository"
}

function install_global
{
    TEMPLATE="$HOME/.git-template-with-git-hooks"
    if [ ! -d "${TEMPLATE}" ] ; then
        DEFAULT=/usr/share/git-core/templates
        if [ -d ${DEFAULT} ] ; then
            cp -rf /usr/share/git-core/templates "${TEMPLATE}"
        else
            mkdir -p "${TEMPLATE}/hooks"
        fi
        cmd="#!/usr/bin/env bash
echo \"git hooks not installed in this repository.  Run 'git hooks --install' to install it or 'git hooks -h' for more information.\"";
        install_hooks_into "${TEMPLATE}" "${cmd}"
        mv "${TEMPLATE}/hooks.old" "${TEMPLATE}/hooks.original"
    fi
    git config --global init.templatedir "${TEMPLATE}"
    echo "Git global config init.templatedir is now set to ${TEMPLATE}"
}

function uninstall_global
{
    git config --global --unset init.templatedir
}

function report_error
{
    echo "Hook failed: $last_run_hook"
    exit 1
}

function link_hook_script
{
    if ! is_hooks_installed; then
        echo "Git hooks are NOT installed in this repository. (Run 'git hooks --install' to install it)"
        exit 1
    fi

    GITDIR="$(git rev-parse --git-dir)"
    local cmd="$1"
    if [ -z "${cmd}" ] || [ ! -f "${GITDIR}/hooks/${cmd}" ]; then
        echo "link requires a valid hook command; choices are:"
        for d in "${hook_dir_names[@]}"; do
            echo "  $d"
        done
        return 1
    fi

    local hook_script_path="$2"
    if [ -z "${hook_script_path}" ]; then
        echo "link requires a hook script path for its second argument"
        return 1
    fi
    if [ ! -x "${hook_script_path}" ] ; then
        echo "The script ${hook_script_path} was not found, or is not executable"
        return 1
    fi

    local script_name="$3"
    if [ -z "${script_name}" ]; then
        script_name="$(basename "${hook_script_path}")"
    fi

    if [[ ! -d "${GITDIR}/../.githooks" ]]; then
        echo "Creating repository git-hooks directory .githooks"
    fi
    local hook_dir="${GITDIR}/../.githooks/${cmd}"
    mkdir -p "${hook_dir}"
    ln -s "${hook_script_path}" "${hook_dir}/${script_name}"
    echo "Linked ${hook_script_path} into this repository as a ${cmd} hook"
}

function unlink_hook_script
{
    if ! is_hooks_installed; then
        echo "Git hooks are NOT installed in this repository. (Run 'git hooks --install' to install it)"
        exit 1
    fi

    GITDIR="$(git rev-parse --git-dir)"
    local cmd="$1"
    if [ -z "${cmd}" ] || [ ! -f "${GITDIR}/hooks/${cmd}" ]; then
        echo "unlink requires a valid hook command; choices are:"
        for d in "${hook_dir_names[@]}"; do
            echo "  $d"
        done
        return 1
    fi

    local script_name="$2"
    if [ -z "${script_name}" ]; then
        echo "link requires a hook script name for its second argument; choices are:"
        for script in "${GITDIR}/../.githooks/${cmd}/"*; do
            echo "  $(basename "$script")"
        done
        return 1
    fi

    local hook_dir="${GITDIR}/../.githooks/${cmd}"
    if [[ "$(test -L . 2>/dev/null)" =~ expected ]]; then
        test -h "${hook_dir}/${script_name}"
    else
        test -L "${hook_dir}/${script_name}"
    fi
     # shellcheck disable=SC2181
    if [ $? -ne 0 ] ; then
        echo "The script ${script_name} is not linked as a ${cmd} hook"
        return 1
    fi

    rm -f "${hook_dir}/${script_name}"
    echo "Unlinked ${script_name} from repository as a ${cmd} hook"
}

case $1 in
    run )
        # shellcheck disable=SC2153
        if [ -n "${GIT_DIR}" ] ; then
            unset GIT_DIR
        fi
        shift
        trap report_error ERR
        run_hook "$@"
        ;;
    link )
        shift
        link_hook_script "$@"
        ;;
    unlink )
        shift
        unlink_hook_script "$@"
        ;;
    --install )
        install_hooks "$1"
        ;;
    --uninstall )
        uninstall_hooks "$1"
        ;;
    --install-global|--installglobal )
        install_global
        ;;
    --uninstall-global|--uninstallglobal )
        uninstall_global
        ;;
    -h|--help|-? )
        echo 'Git Hooks'
        echo '    A tool to manage repository, user, and global Git hooks for multiple git repositories.'
        echo '    https://github.com/bhavanki/git-hooks'
        echo '    forked with gratitude from: https://github.com/icefox/git-hooks'
        echo ''
        echo 'Options:'
        echo '    --install      Replace existing hooks in this repository with a call to'
        echo '                   git hooks run [hook].  Move old hooks directory to hooks.old'
        echo '    --uninstall    Remove existing hooks in this repository and rename hooks.old'
        echo '                   back to hooks'
        echo '    --install-global'
        echo '                   Create a template .git directory that that will be used whenever'
        echo '                   a git repository is created or cloned that will remind the user'
        echo '                   to install git-hooks.'
        echo '    --uninstall-global'
        echo '                   Turn off the global .git directory template that has the reminder.'
        echo '    link <cmd> <path> [<name>]'
        echo '                   Symlink hook script at <path> as hook named <name> (default same'
        echo '                   name as script) for <cmd> (such as pre-commit) into this repository'
        echo '    unlink <cmd> <name>'
        echo '                   Remove hook script named <name> for <cmd> (such as pre-commit) in'
        echo '                   this repository'
        echo '    run <cmd> <args>'
        echo '                   Run the hooks for <cmd> (such as pre-commit), each with <args>'
        echo '    (no arguments) Show currently installed hooks'
        ;;
    * )
        list_hooks
        ;;
esac
